{"ast":null,"code":"import Base64 from 'crypto-js/enc-base64';\nimport HmacSHA1 from 'crypto-js/hmac-sha1';\n\n/**\n * Copyright 2021 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Create a signature for a path and query string using HmacSHA1.\n *\n * ```ts\n * const signature = createSignatureForPathAndQuery(\"/some-path?foo=bar\", \"secret\");\n * ```\n * @param unsignedUrl The URL to sign.\n * @param secret The secret to use for signing.\n * @returns The signature of the signed url.\n */\nfunction createSignatureForPathAndQuery(pathAndQuery, secret) {\n  var decodedSecret = decodeSecret(secret);\n  // Sign the url with the decoded secret\n  var unsafeSignature = HmacSHA1(pathAndQuery, decodedSecret).toString(Base64);\n  // Convert from true base64 to 'web safe' base64\n  return unsafeSignature.replace(/\\+/g, \"-\").replace(/\\//g, \"_\");\n}\n/**\n * Create a signature for a Google Maps request [URL](https://developer.mozilla.org/en-US/docs/Web/API/URL) or url string.\n *\n * ```ts\n * const signature = createSignature(\"https://example.com/some-path?foo=bar\", \"secret\");\n * ```\n *\n * @param unsignedUrl The URL to sign.\n * @param secret The secret to use for signing.\n * @returns The signature of the signed url.\n */\nfunction createSignature(unsignedUrl, secret) {\n  if (typeof unsignedUrl === \"string\") {\n    unsignedUrl = new URL(unsignedUrl);\n  }\n  // Strip off the protocol, scheme, and host portions of the URL, leaving only the path and the query\n  var pathAndQuery = \"\".concat(unsignedUrl.pathname).concat(unsignedUrl.search);\n  return createSignatureForPathAndQuery(pathAndQuery, secret);\n}\n/**\n * Returns a new [URL](https://developer.mozilla.org/en-US/docs/Web/API/URL) having a signature parameter.\n *\n * ```ts\n * const signedUrl = signUrl(\"https://example.com/some-path?foo=bar\", \"secret\");\n * signedUrl.href; // \"https://example.com/some-path?foo=bar&signature=...\"\n * ```\n *\n * @param unsignedUrl The URL to sign.\n * @param secret The secret to use for signing.\n * @returns The signature of the signed url.\n */\nfunction signUrl(unsignedUrl, secret) {\n  if (typeof unsignedUrl === \"string\") {\n    unsignedUrl = new URL(unsignedUrl);\n  }\n  return new URL(unsignedUrl.toString() + \"&signature=\" + createSignature(unsignedUrl, secret));\n}\nfunction decodeSecret(secret) {\n  // Convert from 'web safe' base64 to true base64\n  var unsafeSecret = secret.replace(/-/g, \"+\").replace(/_/g, \"/\");\n  // Base64 decode the secret\n  return Base64.parse(unsafeSecret);\n}\nexport { createSignature, createSignatureForPathAndQuery, signUrl };","map":{"version":3,"names":["createSignatureForPathAndQuery","pathAndQuery","secret","decodedSecret","decodeSecret","unsafeSignature","HmacSHA1","toString","Base64","replace","createSignature","unsignedUrl","URL","concat","pathname","search","signUrl","unsafeSecret","parse"],"sources":["/home/mahnoor/google-place-autocomplete/node_modules/@googlemaps/url-signature/src/index.ts"],"sourcesContent":["/**\n * Copyright 2021 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport Base64 from \"crypto-js/enc-base64\";\nimport HmacSHA1 from \"crypto-js/hmac-sha1\";\nimport CryptoJS from \"crypto-js\";\n\n/**\n * Create a signature for a path and query string using HmacSHA1.\n *\n * ```ts\n * const signature = createSignatureForPathAndQuery(\"/some-path?foo=bar\", \"secret\");\n * ```\n * @param unsignedUrl The URL to sign.\n * @param secret The secret to use for signing.\n * @returns The signature of the signed url.\n */\nexport function createSignatureForPathAndQuery(\n  pathAndQuery: string,\n  secret: string\n): string {\n  const decodedSecret = decodeSecret(secret);\n  // Sign the url with the decoded secret\n  const unsafeSignature = HmacSHA1(pathAndQuery, decodedSecret).toString(\n    Base64\n  );\n  // Convert from true base64 to 'web safe' base64\n  return unsafeSignature.replace(/\\+/g, \"-\").replace(/\\//g, \"_\");\n}\n\n/**\n * Create a signature for a Google Maps request [URL](https://developer.mozilla.org/en-US/docs/Web/API/URL) or url string.\n *\n * ```ts\n * const signature = createSignature(\"https://example.com/some-path?foo=bar\", \"secret\");\n * ```\n *\n * @param unsignedUrl The URL to sign.\n * @param secret The secret to use for signing.\n * @returns The signature of the signed url.\n */\nexport function createSignature(\n  unsignedUrl: URL | string,\n  secret: string\n): string {\n  if (typeof unsignedUrl === \"string\") {\n    unsignedUrl = new URL(unsignedUrl);\n  }\n  // Strip off the protocol, scheme, and host portions of the URL, leaving only the path and the query\n  const pathAndQuery = `${unsignedUrl.pathname}${unsignedUrl.search}`;\n\n  return createSignatureForPathAndQuery(pathAndQuery, secret);\n}\n\n/**\n * Returns a new [URL](https://developer.mozilla.org/en-US/docs/Web/API/URL) having a signature parameter.\n *\n * ```ts\n * const signedUrl = signUrl(\"https://example.com/some-path?foo=bar\", \"secret\");\n * signedUrl.href; // \"https://example.com/some-path?foo=bar&signature=...\"\n * ```\n *\n * @param unsignedUrl The URL to sign.\n * @param secret The secret to use for signing.\n * @returns The signature of the signed url.\n */\nexport function signUrl(unsignedUrl: URL | string, secret: string): URL {\n  if (typeof unsignedUrl === \"string\") {\n    unsignedUrl = new URL(unsignedUrl);\n  }\n  return new URL(\n    unsignedUrl.toString() +\n      \"&signature=\" +\n      createSignature(unsignedUrl, secret)\n  );\n}\n\nfunction decodeSecret(secret: string): CryptoJS.lib.WordArray {\n  // Convert from 'web safe' base64 to true base64\n  const unsafeSecret = secret.replace(/-/g, \"+\").replace(/_/g, \"/\");\n\n  // Base64 decode the secret\n  return Base64.parse(unsafeSecret);\n}\n"],"mappings":";;;AAAA;;;;;;;;;;;;;;AAcG;AAMH;;;;;;;;;AASG;AACa,SAAAA,8BAA8BA,CAC5CC,YAAoB,EACpBC,MAAc;EAEd,IAAMC,aAAa,GAAGC,YAAY,CAACF,MAAM,CAAC;;EAE1C,IAAMG,eAAe,GAAGC,QAAQ,CAACL,YAAY,EAAEE,aAAa,CAAC,CAACI,QAAQ,CACpEC,MAAM,CACP;;EAED,OAAOH,eAAe,CAACI,OAAO,CAAC,KAAK,EAAE,GAAG,CAAC,CAACA,OAAO,CAAC,KAAK,EAAE,GAAG,CAAC;AAChE;AAEA;;;;;;;;;;AAUG;AACa,SAAAC,eAAeA,CAC7BC,WAAyB,EACzBT,MAAc;EAEd,IAAI,OAAOS,WAAW,KAAK,QAAQ,EAAE;IACnCA,WAAW,GAAG,IAAIC,GAAG,CAACD,WAAW,CAAC;EACnC;;EAED,IAAMV,YAAY,GAAG,GAAAY,MAAA,CAAGF,WAAW,CAACG,QAAQ,EAAAD,MAAA,CAAGF,WAAW,CAACI,MAAM,CAAE;EAEnE,OAAOf,8BAA8B,CAACC,YAAY,EAAEC,MAAM,CAAC;AAC7D;AAEA;;;;;;;;;;;AAWG;AACa,SAAAc,OAAOA,CAACL,WAAyB,EAAET,MAAc;EAC/D,IAAI,OAAOS,WAAW,KAAK,QAAQ,EAAE;IACnCA,WAAW,GAAG,IAAIC,GAAG,CAACD,WAAW,CAAC;EACnC;EACD,OAAO,IAAIC,GAAG,CACZD,WAAW,CAACJ,QAAQ,EAAE,GACpB,aAAa,GACbG,eAAe,CAACC,WAAW,EAAET,MAAM,CAAC,CACvC;AACH;AAEA,SAASE,YAAYA,CAACF,MAAc;;EAElC,IAAMe,YAAY,GAAGf,MAAM,CAACO,OAAO,CAAC,IAAI,EAAE,GAAG,CAAC,CAACA,OAAO,CAAC,IAAI,EAAE,GAAG,CAAC;;EAGjE,OAAOD,MAAM,CAACU,KAAK,CAACD,YAAY,CAAC;AACnC"},"metadata":{},"sourceType":"module","externalDependencies":[]}