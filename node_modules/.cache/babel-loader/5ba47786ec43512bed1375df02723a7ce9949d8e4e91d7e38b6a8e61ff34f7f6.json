{"ast":null,"code":"\"use strict\";\n\n/**\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createPremiumPlanQueryString = exports.toTimestamp = exports.serializer = exports.latLngArrayToStringMaybeEncoded = exports.toLatLngLiteral = exports.latLngBoundsToString = exports.objectToString = exports.latLngToString = void 0;\nconst util_1 = require(\"./util\");\nconst url_signature_1 = require(\"@googlemaps/url-signature\");\nconst query_string_1 = require(\"query-string\");\nconst separator = \"|\";\nfunction latLngToString(o) {\n  if (typeof o === \"string\") {\n    return o;\n  } else if (Array.isArray(o) && o.length === 2) {\n    // no transformation\n  } else if (\"lat\" in o && \"lng\" in o) {\n    o = [o.lat, o.lng];\n  } else if (\"latitude\" in o && \"longitude\" in o) {\n    o = [o.latitude, o.longitude];\n  } else {\n    throw new TypeError();\n  }\n  return o.map(x => {\n    return x.toString();\n  }).join(\",\");\n}\nexports.latLngToString = latLngToString;\nfunction objectToString(o) {\n  if (typeof o === \"string\") {\n    return o;\n  } else {\n    let keys = Object.keys(o);\n    keys.sort();\n    return keys.map(k => k + \":\" + o[k]).join(separator);\n  }\n}\nexports.objectToString = objectToString;\nfunction latLngBoundsToString(latLngBounds) {\n  if (typeof latLngBounds === \"string\") {\n    return latLngBounds;\n  } else {\n    return latLngToString(latLngBounds.southwest) + separator + latLngToString(latLngBounds.northeast);\n  }\n}\nexports.latLngBoundsToString = latLngBoundsToString;\nfunction toLatLngLiteral(o) {\n  if (typeof o === \"string\") {\n    const parts = o.split(\",\").map(Number);\n    return {\n      lat: parts[0],\n      lng: parts[1]\n    };\n  } else if (Array.isArray(o) && o.length === 2) {\n    const parts = o.map(Number);\n    return {\n      lat: parts[0],\n      lng: parts[1]\n    };\n  } else if (\"lat\" in o && \"lng\" in o) {\n    return o;\n  } else if (\"latitude\" in o && \"longitude\" in o) {\n    return {\n      lat: o.latitude,\n      lng: o.longitude\n    };\n  } else {\n    throw new TypeError();\n  }\n}\nexports.toLatLngLiteral = toLatLngLiteral;\nfunction latLngArrayToStringMaybeEncoded(o) {\n  if (typeof o === \"string\") {\n    return o;\n  }\n  const concatenated = o.map(latLngToString).join(separator);\n  const encoded = `enc:${(0, util_1.encodePath)(o.map(toLatLngLiteral))}`;\n  if (encoded.length < concatenated.length) {\n    return encoded;\n  }\n  return concatenated;\n}\nexports.latLngArrayToStringMaybeEncoded = latLngArrayToStringMaybeEncoded;\nfunction serializer(format, baseUrl) {\n  let queryStringOptions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {\n    arrayFormat: \"separator\",\n    arrayFormatSeparator: separator\n  };\n  return params => {\n    // avoid mutating params\n    const serializedParams = Object.assign({}, params);\n    Object.keys(format).forEach(key => {\n      if (key in serializedParams) {\n        serializedParams[key] = format[key](serializedParams[key]);\n      }\n    });\n    if (\"client_id\" in serializedParams && \"client_secret\" in serializedParams) {\n      // Special case to handle premium plan signature\n      return createPremiumPlanQueryString(serializedParams, queryStringOptions, baseUrl);\n    }\n    return (0, query_string_1.stringify)(serializedParams, queryStringOptions);\n  };\n}\nexports.serializer = serializer;\nfunction toTimestamp(o) {\n  if (o === \"now\") {\n    return o;\n  }\n  if (o instanceof Date) {\n    return Math.round(Number(o) / 1000);\n  }\n  return o;\n}\nexports.toTimestamp = toTimestamp;\nfunction createPremiumPlanQueryString(serializedParams, queryStringOptions, baseUrl) {\n  serializedParams.client = serializedParams.client_id;\n  const clientSecret = serializedParams.client_secret;\n  delete serializedParams.client_id;\n  delete serializedParams.client_secret;\n  const partialQueryString = (0, query_string_1.stringify)(serializedParams, queryStringOptions);\n  const unsignedUrl = `${baseUrl}?${partialQueryString}`;\n  const signature = (0, url_signature_1.createSignature)(unsignedUrl, clientSecret);\n  // The signature must come last\n  return `${partialQueryString}&signature=${signature}`;\n}\nexports.createPremiumPlanQueryString = createPremiumPlanQueryString;","map":{"version":3,"names":["util_1","require","url_signature_1","query_string_1","separator","latLngToString","o","Array","isArray","length","lat","lng","latitude","longitude","TypeError","map","x","toString","join","exports","objectToString","keys","Object","sort","k","latLngBoundsToString","latLngBounds","southwest","northeast","toLatLngLiteral","parts","split","Number","latLngArrayToStringMaybeEncoded","concatenated","encoded","encodePath","serializer","format","baseUrl","queryStringOptions","arguments","undefined","arrayFormat","arrayFormatSeparator","params","serializedParams","assign","forEach","key","createPremiumPlanQueryString","stringify","toTimestamp","Date","Math","round","client","client_id","clientSecret","client_secret","partialQueryString","unsignedUrl","signature","createSignature"],"sources":["/home/mahnoor/google-place-autocomplete/node_modules/@googlemaps/google-maps-services-js/src/serialize.ts"],"sourcesContent":["/**\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { LatLng, LatLngBounds, LatLngLiteral } from \"./common\";\n\nimport { encodePath } from \"./util\";\nimport { createSignature} from \"@googlemaps/url-signature\";\nimport { stringify as qs } from \"query-string\";\n\nconst separator = \"|\";\n\nexport function latLngToString(o: LatLng) {\n  if (typeof o === \"string\") {\n    return o;\n  } else if (Array.isArray(o) && o.length === 2) {\n    // no transformation\n  } else if (\"lat\" in o && \"lng\" in o) {\n    o = [o.lat, o.lng];\n  } else if (\"latitude\" in o && \"longitude\" in o) {\n    o = [o.latitude, o.longitude];\n  } else {\n    throw new TypeError();\n  }\n\n  return o\n    .map((x) => {\n      return x.toString();\n    })\n    .join(\",\");\n}\n\nexport function objectToString(o: string | object): string {\n  if (typeof o === \"string\") {\n    return o;\n  } else {\n    let keys = Object.keys(o);\n    keys.sort();\n    return keys.map((k) => k + \":\" + o[k]).join(separator);\n  }\n}\n\nexport function latLngBoundsToString(latLngBounds: string | LatLngBounds) {\n  if (typeof latLngBounds === \"string\") {\n    return latLngBounds;\n  } else {\n    return (\n      latLngToString(latLngBounds.southwest) +\n      separator +\n      latLngToString(latLngBounds.northeast)\n    );\n  }\n}\n\nexport function toLatLngLiteral(o: LatLng): LatLngLiteral {\n  if (typeof o === \"string\") {\n    const parts = o.split(\",\").map(Number);\n    return { lat: parts[0], lng: parts[1] };\n  } else if (Array.isArray(o) && o.length === 2) {\n    const parts = o.map(Number);\n    return { lat: parts[0], lng: parts[1] };\n  } else if (\"lat\" in o && \"lng\" in o) {\n    return o;\n  } else if (\"latitude\" in o && \"longitude\" in o) {\n    return { lat: o.latitude, lng: o.longitude };\n  } else {\n    throw new TypeError();\n  }\n}\n\nexport function latLngArrayToStringMaybeEncoded(o: string | LatLng[]): string {\n  if (typeof o === \"string\") {\n    return o;\n  }\n\n  const concatenated = o.map(latLngToString).join(separator);\n  const encoded = `enc:${encodePath(o.map(toLatLngLiteral))}`;\n\n  if (encoded.length < concatenated.length) {\n    return encoded;\n  }\n\n  return concatenated;\n}\n\nexport type serializerFunction = (any) => string | number | boolean;\nexport type serializerFormat = { [key: string]: serializerFunction };\n\nexport function serializer(\n  format: serializerFormat,\n  baseUrl: string,\n  queryStringOptions: object = {\n    arrayFormat: \"separator\",\n    arrayFormatSeparator: separator,\n  }\n) {\n  return (params: { [key: string]: any }) => {\n    // avoid mutating params\n    const serializedParams = { ...params };\n\n    Object.keys(format).forEach((key: string) => {\n      if (key in serializedParams) {\n        serializedParams[key] = format[key](serializedParams[key]);\n      }\n    });\n\n    if (\"client_id\" in serializedParams && \"client_secret\" in serializedParams) {\n      // Special case to handle premium plan signature\n      return createPremiumPlanQueryString(serializedParams, queryStringOptions, baseUrl);\n    }\n\n    return qs(serializedParams, queryStringOptions);\n  };\n}\n\nexport function toTimestamp(o: \"now\" | number | Date): number | \"now\" {\n  if (o === \"now\") {\n    return o;\n  }\n  if (o instanceof Date) {\n    return Math.round(Number(o) / 1000);\n  }\n  return o;\n}\n\nexport function createPremiumPlanQueryString(\n  serializedParams: { [key: string]: string },\n  queryStringOptions: object,\n  baseUrl: string,\n): string {\n  serializedParams.client = serializedParams.client_id;\n  const clientSecret = serializedParams.client_secret;\n  delete serializedParams.client_id;\n  delete serializedParams.client_secret;\n\n  const partialQueryString = qs(serializedParams, queryStringOptions);\n  const unsignedUrl = `${baseUrl}?${partialQueryString}`;\n  const signature =  createSignature(unsignedUrl, clientSecret);\n\n  // The signature must come last\n  return `${partialQueryString}&signature=${signature}`;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}