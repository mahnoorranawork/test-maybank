{"ast":null,"code":"\"use strict\";\n\n/**\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.decodePath = exports.encodePath = void 0;\n/**\n * Polyline encodes an array of LatLng objects.\n *\n * See {@link https://developers.google.com/maps/documentation/utilities/polylinealgorithm}\n *\n */\nfunction encodePath(path) {\n  var result = [];\n  var start = [0, 0];\n  var end;\n  var encodePart = function (part) {\n    part = part < 0 ? ~(part << 1) : part << 1;\n    while (part >= 0x20) {\n      result.push(String.fromCharCode((0x20 | part & 0x1f) + 63));\n      part >>= 5;\n    }\n    result.push(String.fromCharCode(part + 63));\n  };\n  for (let i = 0, I = path.length || 0; i < I; ++i) {\n    end = [Math.round(path[i].lat * 1e5), Math.round(path[i].lng * 1e5)];\n    encodePart(end[0] - start[0]); // lat\n    encodePart(end[1] - start[1]); // lng\n    start = end;\n  }\n  return result.join(\"\");\n}\nexports.encodePath = encodePath;\n/**\n * Decodes a polyline encoded string.\n *\n * See {@link https://developers.google.com/maps/documentation/utilities/polylinealgorithm}\n */\nfunction decodePath(encodedPath) {\n  let len = encodedPath.length || 0;\n  let path = new Array(Math.floor(encodedPath.length / 2));\n  let index = 0;\n  let lat = 0;\n  let lng = 0;\n  let pointIndex;\n  for (pointIndex = 0; index < len; ++pointIndex) {\n    let result = 1;\n    let shift = 0;\n    let b;\n    do {\n      b = encodedPath.charCodeAt(index++) - 63 - 1;\n      result += b << shift;\n      shift += 5;\n    } while (b >= 0x1f);\n    lat += result & 1 ? ~(result >> 1) : result >> 1;\n    result = 1;\n    shift = 0;\n    do {\n      b = encodedPath.charCodeAt(index++) - 63 - 1;\n      result += b << shift;\n      shift += 5;\n    } while (b >= 0x1f);\n    lng += result & 1 ? ~(result >> 1) : result >> 1;\n    path[pointIndex] = {\n      lat: lat * 1e-5,\n      lng: lng * 1e-5\n    };\n  }\n  path.length = pointIndex;\n  return path;\n}\nexports.decodePath = decodePath;","map":{"version":3,"names":["encodePath","path","result","start","end","encodePart","part","push","String","fromCharCode","i","I","length","Math","round","lat","lng","join","exports","decodePath","encodedPath","len","Array","floor","index","pointIndex","shift","b","charCodeAt"],"sources":["/home/mahnoor/google-place-autocomplete/node_modules/@googlemaps/google-maps-services-js/src/util.ts"],"sourcesContent":["/**\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { LatLngLiteral } from \"./common\";\n\n/**\n * Polyline encodes an array of LatLng objects.\n *\n * See {@link https://developers.google.com/maps/documentation/utilities/polylinealgorithm}\n *\n */\nexport function encodePath(path: LatLngLiteral[]): string {\n  var result: string[] = [];\n  var start: [number, number] = [0, 0];\n  var end: [number, number];\n\n  var encodePart = function(part: number) {\n    part = part < 0 ? ~(part << 1) : part << 1;\n    while (part >= 0x20) {\n      result.push(String.fromCharCode((0x20 | (part & 0x1f)) + 63));\n      part >>= 5;\n    }\n    result.push(String.fromCharCode(part + 63));\n  };\n\n  for (let i = 0, I = path.length || 0; i < I; ++i) {\n    end = [Math.round(path[i].lat * 1e5), Math.round(path[i].lng * 1e5)];\n    encodePart(end[0] - start[0]); // lat\n    encodePart(end[1] - start[1]); // lng\n    start = end;\n  }\n\n  return result.join(\"\");\n}\n\n/**\n * Decodes a polyline encoded string.\n *\n * See {@link https://developers.google.com/maps/documentation/utilities/polylinealgorithm}\n */\nexport function decodePath(encodedPath: string): LatLngLiteral[] {\n  let len: number = encodedPath.length || 0;\n  let path = new Array(Math.floor(encodedPath.length / 2));\n  let index: number = 0;\n  let lat: number = 0;\n  let lng: number = 0;\n  let pointIndex: number;\n\n  for (pointIndex = 0; index < len; ++pointIndex) {\n    let result: number = 1;\n    let shift: number = 0;\n    let b: number;\n    do {\n      b = encodedPath.charCodeAt(index++) - 63 - 1;\n      result += b << shift;\n      shift += 5;\n    } while (b >= 0x1f);\n    lat += result & 1 ? ~(result >> 1) : result >> 1;\n\n    result = 1;\n    shift = 0;\n    do {\n      b = encodedPath.charCodeAt(index++) - 63 - 1;\n      result += b << shift;\n      shift += 5;\n    } while (b >= 0x1f);\n    lng += result & 1 ? ~(result >> 1) : result >> 1;\n\n    path[pointIndex] = { lat: lat * 1e-5, lng: lng * 1e-5 };\n  }\n  path.length = pointIndex;\n\n  return path;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}